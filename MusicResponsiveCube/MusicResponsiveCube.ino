/* LED cube responding to audio by frequency (starter code)
 *
 * Shows a real-time frequency spectrum on an LED cube.
 *
 * == Setting up the Serial Monitor ==
 * The Serial Monitor must be configured (bottom-right corner of the screen) as
 * baud rate 115200.
 *
 * ENGR 40M
 * November 2015
 */

// FFT library options
// See http://wiki.openmusiclabs.com/wiki/Defines if you're curious.
#define FFT_N 16 // you can change this if you like - see the note in setLEDs.
#define WINDOW 0
#define OCTAVE 1
#define OCT_NORM 0
#include <FFT.h>

#define SAMPLE_PERIOD_MICROSECONDS 250
const byte ANODE_PINS[8] = {6, 7, 8, 9, 2, 3, 4, 5};
const byte CATHODE_PINS[8] = {A2, A3, A4, A5, 11, 12, 10, 13};
const byte audioPin = A1;
const int MAX_BIN_VALUE = 816;
const int DIVIDE_FACTOR = 16; 

void setup()
{
  // Make all of the anode (+) wire and cathode (-) wire pins outputs
  for (byte i = 0; i < 8; i++) {
    pinMode(ANODE_PINS[i], OUTPUT);
    pinMode(CATHODE_PINS[i], OUTPUT);
  }
  pinMode(audioPin, INPUT_PULLUP);
  // Set all LEDs to OFF state
  for (byte j = 0; j < 8; j++) {
    digitalWrite(ANODE_PINS[j], HIGH);
    digitalWrite(CATHODE_PINS[j], LOW);
  }
  // Initialize serial communication
  // (to be read by Serial Monitor on your computer)
  Serial.begin(115200);
  Serial.setTimeout(100);
}

/* Function: getLEDState
 * ------------------
 * Returns the value in a 4x4x4 values array, each dimension representing an
 * axis of the LED cube, that corresponds to the given positive and negative number.
 *
 * This function is called by display(), in order to find whether an LED for a
 * particular positive and negative should be switched on.
 */
inline byte getLEDState(byte pattern[4][4][4], byte aNum, byte cNum)
{
  byte aMap = aNum % 4;
  byte cMap = cNum % 4;
  byte x;
  byte y;
  byte z;
  byte anodeZ1;
  byte anodeZ2;
  byte cathodeZ1;
  byte cathodeZ2;
  // Switch statement utilizes organization of circuitry to find x coordinate using aNum % 4
  switch (aMap) {
    case 0:
      x = 0;
    break;
    case 1:
      x = 1;
    break;
    case 2:
      x = 2;
    break;
    case 3:
      x = 3;
    break;
  }
  // Switch statement utilizes organization of circuitry to find y coordinate using cNum % 4
  switch (cMap) {
    case 0:
      y = 0;
    break;
    case 1:
      y = 1;
    break;
    case 2:
      y = 2;
    break;
    case 3:
      y = 3;
    break;
  }
  // Finds the two possible z coordinates associated with the given anode number based upon circuitry
  if (aNum == 0 || aNum == 1 || aNum == 2 || aNum == 3) {
    anodeZ1 = 1;
    anodeZ2 = 0; 
  } else {
    anodeZ1 = 2;
    anodeZ2 = 3;
  }
  // Finds the two possible z coordinates associated with the given cathode number based upon the circuitry
  if (cNum == 0 || cNum == 1 || cNum == 2 || cNum == 3) {
    cathodeZ1 = 0;
    cathodeZ2 = 3;
  } else {
    cathodeZ1 = 1;
    cathodeZ2 = 2;
  }
  // Finds value of z using conditional logic
  if (cathodeZ1 == anodeZ1 || cathodeZ1 == anodeZ2) {
    z = cathodeZ1;
  } else {
    z = cathodeZ2;
  }
  return pattern[x][y][z];
  return 0;
}

/* Function: display
 * -----------------
 * Runs through one multiplexing cycle of the LEDs, controlling which LEDs are
 * on.
 *
 * During this function, LEDs that should be on will be turned on momentarily,
 * one row at a time. When this function returns, all the LEDs will be off
 * again, so it needs to be called continuously for LEDs to be on.
 */
void display(byte pattern[4][4][4])
{
  for (byte aNum = 0; aNum < 8; aNum++) { // iterate through anode (+) wires

    // Set up all the cathode (-) wires first
    for (byte cNum = 0; cNum < 8; cNum++) { // iterate through cathode (-) wires
      byte value = getLEDState(pattern, aNum, cNum); // look up the value
      if (value > 0) {
        digitalWrite(CATHODE_PINS[cNum], LOW);
      } else {
        digitalWrite(CATHODE_PINS[cNum], HIGH);
      }
    }

    // Activate the anode (+) wire (without condition)
    digitalWrite(ANODE_PINS[aNum], LOW);
    // Wait a short time
    delayMicroseconds(100);

    // We're now done with this row, so deactivate the anode (+) wire
    digitalWrite(ANODE_PINS[aNum], HIGH);
  }
}

/* Function: getSamples
 * --------------------
 * Populates every other element of an array with FFT_N samples, sampled at
 * 1000/SAMPLE_PERIOD_MICROSECONDS kHz. Takes about 6.7ms to run.
 */
void getSamples(int samples[FFT_N*2]) {
  unsigned long next_sample_time = micros();
  for (byte i = 0; i < FFT_N*2; i+=2) {
    while (micros() < next_sample_time); // wait till next sample time
    samples[i] = analogRead(audioPin) - 512;
    samples[i+1] = 0;
    next_sample_time += SAMPLE_PERIOD_MICROSECONDS;
  }
}

/* Function: setLEDs
 * -----------------
 * Sets the LEDs array based on the given frequency bin values. The bins are
 * assumed to be of the form generated by fft_mag_octave() of the ArduinoFFT
 * library.
 *
 * LOG_N is defined in FFT.h as log2(FFT_N), so if FFT_N = 16, LOG_N = 4.
 */
void setLEDs(byte pattern[4][4][4], byte bins[LOG_N]) {
  static char message[20];
  sprintf(message, "%d %d %d %d\n", bins[0], bins[1], bins[2], bins[3]);
  Serial.print(message);
  // TODO
  // Based on the values in bins[LOG_N], write code to set each element each
  // element in the ledOn[4][4][4] array. This can be as simple or as fancy
  // as you like, though maybe don't get too carried away until you've finished
  // the rest of the lab!
  //
  // You might like to run this with the Serial Monitor to get a feel for what
  // sort of values you're finding in bins[LOG_N]. The code above prints the
  // four numbers to the Serial Monitor.
  int binValues[4];
  for (int i = 0; i < 4; i++) {
    binValues[i] = (bins[i] / DIVIDE_FACTOR);
    Serial.println(bins[i]); 
  }
  int nLEDS;
  for (int binNumber = 0; binNumber < 4; binNumber++) {
    nLEDS = binValues[binNumber];   
    for (int y = 0; y < 4; y++) {
      for (int x = 0; x < 4; x++) {
        pattern[x][y][binNumber] = HIGH;
        nLEDS--;
        if (nLEDS <= 0) {
          break; 
        }
      }
    }
  }
}


void loop()
{
    static byte pattern[4][4][4];

    getSamples(fft_input);

    // These three functions run the FFT on the data in the global array
    // fft_input. The result will be in the global array fft_oct_out. If you're
    // curious, you can look at http://wiki.openmusiclabs.com/wiki/FFTFunctions
    // for other variants of these functions to use instead.
    fft_reorder();
    fft_run();
    fft_mag_octave();

    setLEDs(pattern, fft_oct_out);
    display(pattern);
}

